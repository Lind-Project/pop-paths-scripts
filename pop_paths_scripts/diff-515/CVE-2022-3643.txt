<!DOCTYPE html>
<html lang='en'>
<head>
<title>kernel/git/torvalds/linux.git - Linux kernel source tree</title>
<meta name='generator' content='cgit '/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='http://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a title='kernel/git/torvalds/linux.git' href='/pub/scm/linux/kernel/git/torvalds/linux.git/'>kernel/git/torvalds/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='0fe29bd92594a747a2561589bd452c259451929e'/><select name='h' onchange='this.form.submit();'>
<option value='master' selected='selected'>master</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel source tree</td><td class='sub right'>Linus Torvalds</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=0fe29bd92594a747a2561589bd452c259451929e'>refs</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=0fe29bd92594a747a2561589bd452c259451929e'>tree</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=0fe29bd92594a747a2561589bd452c259451929e'>commit</a><a class='active' href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=0fe29bd92594a747a2561589bd452c259451929e'>diff</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/torvalds/linux.git/log/'>
<input type='hidden' name='id' value='0fe29bd92594a747a2561589bd452c259451929e'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='0fe29bd92594a747a2561589bd452c259451929e'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=0fe29bd92594a747a2561589bd452c259451929e'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/drivers/net/xen-netback/netback.c?id=0fe29bd92594a747a2561589bd452c259451929e'>drivers/net/xen-netback/netback.c</a></td><td class='right'>223</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 55.2%;'/><td class='rem' style='width: 44.8%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>1 files changed, 123 insertions, 100 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c<br/>index 32d5bc4919d8c..a5c26772ec1f2 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/xen-netback/netback.c?id=f01677be31d1d52f2330f6f94d6bd943b9317692'>drivers/net/xen-netback/netback.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/net/xen-netback/netback.c?id=0fe29bd92594a747a2561589bd452c259451929e'>drivers/net/xen-netback/netback.c</a></div><div class='hunk'>@@ -330,10 +330,13 @@ static int xenvif_count_requests(struct xenvif_queue *queue,</div><div class='ctx'> </div><div class='ctx'> </div><div class='ctx'> struct xenvif_tx_cb {</div><div class='del'>-	u16 pending_idx;</div><div class='add'>+	u16 copy_pending_idx[XEN_NETBK_LEGACY_SLOTS_MAX + 1];</div><div class='add'>+	u8 copy_count;</div><div class='ctx'> };</div><div class='ctx'> </div><div class='ctx'> #define XENVIF_TX_CB(skb) ((struct xenvif_tx_cb *)(skb)-&gt;cb)</div><div class='add'>+#define copy_pending_idx(skb, i) (XENVIF_TX_CB(skb)-&gt;copy_pending_idx[i])</div><div class='add'>+#define copy_count(skb) (XENVIF_TX_CB(skb)-&gt;copy_count)</div><div class='ctx'> </div><div class='ctx'> static inline void xenvif_tx_create_map_op(struct xenvif_queue *queue,</div><div class='ctx'> 					   u16 pending_idx,</div><div class='hunk'>@@ -368,31 +371,93 @@ static inline struct sk_buff *xenvif_alloc_skb(unsigned int size)</div><div class='ctx'> 	return skb;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-static struct gnttab_map_grant_ref *xenvif_get_requests(struct xenvif_queue *queue,</div><div class='del'>-							struct sk_buff *skb,</div><div class='del'>-							struct xen_netif_tx_request *txp,</div><div class='del'>-							struct gnttab_map_grant_ref *gop,</div><div class='del'>-							unsigned int frag_overflow,</div><div class='del'>-							struct sk_buff *nskb)</div><div class='add'>+static void xenvif_get_requests(struct xenvif_queue *queue,</div><div class='add'>+				struct sk_buff *skb,</div><div class='add'>+				struct xen_netif_tx_request *first,</div><div class='add'>+				struct xen_netif_tx_request *txfrags,</div><div class='add'>+			        unsigned *copy_ops,</div><div class='add'>+			        unsigned *map_ops,</div><div class='add'>+				unsigned int frag_overflow,</div><div class='add'>+				struct sk_buff *nskb,</div><div class='add'>+				unsigned int extra_count,</div><div class='add'>+				unsigned int data_len)</div><div class='ctx'> {</div><div class='ctx'> 	struct skb_shared_info *shinfo = skb_shinfo(skb);</div><div class='ctx'> 	skb_frag_t *frags = shinfo-&gt;frags;</div><div class='del'>-	u16 pending_idx = XENVIF_TX_CB(skb)-&gt;pending_idx;</div><div class='del'>-	int start;</div><div class='add'>+	u16 pending_idx;</div><div class='ctx'> 	pending_ring_idx_t index;</div><div class='ctx'> 	unsigned int nr_slots;</div><div class='add'>+	struct gnttab_copy *cop = queue-&gt;tx_copy_ops + *copy_ops;</div><div class='add'>+	struct gnttab_map_grant_ref *gop = queue-&gt;tx_map_ops + *map_ops;</div><div class='add'>+	struct xen_netif_tx_request *txp = first;</div><div class='add'>+</div><div class='add'>+	nr_slots = shinfo-&gt;nr_frags + 1;</div><div class='add'>+</div><div class='add'>+	copy_count(skb) = 0;</div><div class='add'>+</div><div class='add'>+	/* Create copy ops for exactly data_len bytes into the skb head. */</div><div class='add'>+	__skb_put(skb, data_len);</div><div class='add'>+	while (data_len &gt; 0) {</div><div class='add'>+		int amount = data_len &gt; txp-&gt;size ? txp-&gt;size : data_len;</div><div class='add'>+</div><div class='add'>+		cop-&gt;source.u.ref = txp-&gt;gref;</div><div class='add'>+		cop-&gt;source.domid = queue-&gt;vif-&gt;domid;</div><div class='add'>+		cop-&gt;source.offset = txp-&gt;offset;</div><div class='add'>+</div><div class='add'>+		cop-&gt;dest.domid = DOMID_SELF;</div><div class='add'>+		cop-&gt;dest.offset = (offset_in_page(skb-&gt;data +</div><div class='add'>+						   skb_headlen(skb) -</div><div class='add'>+						   data_len)) &amp; ~XEN_PAGE_MASK;</div><div class='add'>+		cop-&gt;dest.u.gmfn = virt_to_gfn(skb-&gt;data + skb_headlen(skb)</div><div class='add'>+				               - data_len);</div><div class='add'>+</div><div class='add'>+		cop-&gt;len = amount;</div><div class='add'>+		cop-&gt;flags = GNTCOPY_source_gref;</div><div class='ctx'> </div><div class='del'>-	nr_slots = shinfo-&gt;nr_frags;</div><div class='add'>+		index = pending_index(queue-&gt;pending_cons);</div><div class='add'>+		pending_idx = queue-&gt;pending_ring[index];</div><div class='add'>+		callback_param(queue, pending_idx).ctx = NULL;</div><div class='add'>+		copy_pending_idx(skb, copy_count(skb)) = pending_idx;</div><div class='add'>+		copy_count(skb)++;</div><div class='add'>+</div><div class='add'>+		cop++;</div><div class='add'>+		data_len -= amount;</div><div class='ctx'> </div><div class='del'>-	/* Skip first skb fragment if it is on same page as header fragment. */</div><div class='del'>-	start = (frag_get_pending_idx(&amp;shinfo-&gt;frags[0]) == pending_idx);</div><div class='add'>+		if (amount == txp-&gt;size) {</div><div class='add'>+			/* The copy op covered the full tx_request */</div><div class='add'>+</div><div class='add'>+			memcpy(&amp;queue-&gt;pending_tx_info[pending_idx].req,</div><div class='add'>+			       txp, sizeof(*txp));</div><div class='add'>+			queue-&gt;pending_tx_info[pending_idx].extra_count =</div><div class='add'>+				(txp == first) ? extra_count : 0;</div><div class='add'>+</div><div class='add'>+			if (txp == first)</div><div class='add'>+				txp = txfrags;</div><div class='add'>+			else</div><div class='add'>+				txp++;</div><div class='add'>+			queue-&gt;pending_cons++;</div><div class='add'>+			nr_slots--;</div><div class='add'>+		} else {</div><div class='add'>+			/* The copy op partially covered the tx_request.</div><div class='add'>+			 * The remainder will be mapped.</div><div class='add'>+			 */</div><div class='add'>+			txp-&gt;offset += amount;</div><div class='add'>+			txp-&gt;size -= amount;</div><div class='add'>+		}</div><div class='add'>+	}</div><div class='ctx'> </div><div class='del'>-	for (shinfo-&gt;nr_frags = start; shinfo-&gt;nr_frags &lt; nr_slots;</div><div class='del'>-	     shinfo-&gt;nr_frags++, txp++, gop++) {</div><div class='add'>+	for (shinfo-&gt;nr_frags = 0; shinfo-&gt;nr_frags &lt; nr_slots;</div><div class='add'>+	     shinfo-&gt;nr_frags++, gop++) {</div><div class='ctx'> 		index = pending_index(queue-&gt;pending_cons++);</div><div class='ctx'> 		pending_idx = queue-&gt;pending_ring[index];</div><div class='del'>-		xenvif_tx_create_map_op(queue, pending_idx, txp, 0, gop);</div><div class='add'>+		xenvif_tx_create_map_op(queue, pending_idx, txp,</div><div class='add'>+				        txp == first ? extra_count : 0, gop);</div><div class='ctx'> 		frag_set_pending_idx(&amp;frags[shinfo-&gt;nr_frags], pending_idx);</div><div class='add'>+</div><div class='add'>+		if (txp == first)</div><div class='add'>+			txp = txfrags;</div><div class='add'>+		else</div><div class='add'>+			txp++;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> 	if (frag_overflow) {</div><div class='hunk'>@@ -413,7 +478,8 @@ static struct gnttab_map_grant_ref *xenvif_get_requests(struct xenvif_queue *que</div><div class='ctx'> 		skb_shinfo(skb)-&gt;frag_list = nskb;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	return gop;</div><div class='add'>+	(*copy_ops) = cop - queue-&gt;tx_copy_ops;</div><div class='add'>+	(*map_ops) = gop - queue-&gt;tx_map_ops;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> static inline void xenvif_grant_handle_set(struct xenvif_queue *queue,</div><div class='hunk'>@@ -449,7 +515,7 @@ static int xenvif_tx_check_gop(struct xenvif_queue *queue,</div><div class='ctx'> 			       struct gnttab_copy **gopp_copy)</div><div class='ctx'> {</div><div class='ctx'> 	struct gnttab_map_grant_ref *gop_map = *gopp_map;</div><div class='del'>-	u16 pending_idx = XENVIF_TX_CB(skb)-&gt;pending_idx;</div><div class='add'>+	u16 pending_idx;</div><div class='ctx'> 	/* This always points to the shinfo of the skb being checked, which</div><div class='ctx'> 	 * could be either the first or the one on the frag_list</div><div class='ctx'> 	 */</div><div class='hunk'>@@ -460,24 +526,37 @@ static int xenvif_tx_check_gop(struct xenvif_queue *queue,</div><div class='ctx'> 	struct skb_shared_info *first_shinfo = NULL;</div><div class='ctx'> 	int nr_frags = shinfo-&gt;nr_frags;</div><div class='ctx'> 	const bool sharedslot = nr_frags &amp;&amp;</div><div class='del'>-				frag_get_pending_idx(&amp;shinfo-&gt;frags[0]) == pending_idx;</div><div class='add'>+				frag_get_pending_idx(&amp;shinfo-&gt;frags[0]) ==</div><div class='add'>+				    copy_pending_idx(skb, copy_count(skb) - 1);</div><div class='ctx'> 	int i, err;</div><div class='ctx'> </div><div class='del'>-	/* Check status of header. */</div><div class='del'>-	err = (*gopp_copy)-&gt;status;</div><div class='del'>-	if (unlikely(err)) {</div><div class='del'>-		if (net_ratelimit())</div><div class='del'>-			netdev_dbg(queue-&gt;vif-&gt;dev,</div><div class='del'>-				   "Grant copy of header failed! status: %d pending_idx: %u ref: %u\n",</div><div class='del'>-				   (*gopp_copy)-&gt;status,</div><div class='del'>-				   pending_idx,</div><div class='del'>-				   (*gopp_copy)-&gt;source.u.ref);</div><div class='del'>-		/* The first frag might still have this slot mapped */</div><div class='del'>-		if (!sharedslot)</div><div class='del'>-			xenvif_idx_release(queue, pending_idx,</div><div class='del'>-					   XEN_NETIF_RSP_ERROR);</div><div class='add'>+	for (i = 0; i &lt; copy_count(skb); i++) {</div><div class='add'>+		int newerr;</div><div class='add'>+</div><div class='add'>+		/* Check status of header. */</div><div class='add'>+		pending_idx = copy_pending_idx(skb, i);</div><div class='add'>+</div><div class='add'>+		newerr = (*gopp_copy)-&gt;status;</div><div class='add'>+		if (likely(!newerr)) {</div><div class='add'>+			/* The first frag might still have this slot mapped */</div><div class='add'>+			if (i &lt; copy_count(skb) - 1 || !sharedslot)</div><div class='add'>+				xenvif_idx_release(queue, pending_idx,</div><div class='add'>+						   XEN_NETIF_RSP_OKAY);</div><div class='add'>+		} else {</div><div class='add'>+			err = newerr;</div><div class='add'>+			if (net_ratelimit())</div><div class='add'>+				netdev_dbg(queue-&gt;vif-&gt;dev,</div><div class='add'>+					   "Grant copy of header failed! status: %d pending_idx: %u ref: %u\n",</div><div class='add'>+					   (*gopp_copy)-&gt;status,</div><div class='add'>+					   pending_idx,</div><div class='add'>+					   (*gopp_copy)-&gt;source.u.ref);</div><div class='add'>+			/* The first frag might still have this slot mapped */</div><div class='add'>+			if (i &lt; copy_count(skb) - 1 || !sharedslot)</div><div class='add'>+				xenvif_idx_release(queue, pending_idx,</div><div class='add'>+						   XEN_NETIF_RSP_ERROR);</div><div class='add'>+		}</div><div class='add'>+		(*gopp_copy)++;</div><div class='ctx'> 	}</div><div class='del'>-	(*gopp_copy)++;</div><div class='ctx'> </div><div class='ctx'> check_frags:</div><div class='ctx'> 	for (i = 0; i &lt; nr_frags; i++, gop_map++) {</div><div class='hunk'>@@ -524,14 +603,6 @@ check_frags:</div><div class='ctx'> 		if (err)</div><div class='ctx'> 			continue;</div><div class='ctx'> </div><div class='del'>-		/* First error: if the header haven't shared a slot with the</div><div class='del'>-		 * first frag, release it as well.</div><div class='del'>-		 */</div><div class='del'>-		if (!sharedslot)</div><div class='del'>-			xenvif_idx_release(queue,</div><div class='del'>-					   XENVIF_TX_CB(skb)-&gt;pending_idx,</div><div class='del'>-					   XEN_NETIF_RSP_OKAY);</div><div class='del'>-</div><div class='ctx'> 		/* Invalidate preceding fragments of this skb. */</div><div class='ctx'> 		for (j = 0; j &lt; i; j++) {</div><div class='ctx'> 			pending_idx = frag_get_pending_idx(&amp;shinfo-&gt;frags[j]);</div><div class='hunk'>@@ -801,7 +872,6 @@ static void xenvif_tx_build_gops(struct xenvif_queue *queue,</div><div class='ctx'> 				     unsigned *copy_ops,</div><div class='ctx'> 				     unsigned *map_ops)</div><div class='ctx'> {</div><div class='del'>-	struct gnttab_map_grant_ref *gop = queue-&gt;tx_map_ops;</div><div class='ctx'> 	struct sk_buff *skb, *nskb;</div><div class='ctx'> 	int ret;</div><div class='ctx'> 	unsigned int frag_overflow;</div><div class='hunk'>@@ -883,8 +953,12 @@ static void xenvif_tx_build_gops(struct xenvif_queue *queue,</div><div class='ctx'> 			continue;</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='add'>+		data_len = (txreq.size &gt; XEN_NETBACK_TX_COPY_LEN) ?</div><div class='add'>+			XEN_NETBACK_TX_COPY_LEN : txreq.size;</div><div class='add'>+</div><div class='ctx'> 		ret = xenvif_count_requests(queue, &amp;txreq, extra_count,</div><div class='ctx'> 					    txfrags, work_to_do);</div><div class='add'>+</div><div class='ctx'> 		if (unlikely(ret &lt; 0))</div><div class='ctx'> 			break;</div><div class='ctx'> </div><div class='hunk'>@@ -910,9 +984,8 @@ static void xenvif_tx_build_gops(struct xenvif_queue *queue,</div><div class='ctx'> 		index = pending_index(queue-&gt;pending_cons);</div><div class='ctx'> 		pending_idx = queue-&gt;pending_ring[index];</div><div class='ctx'> </div><div class='del'>-		data_len = (txreq.size &gt; XEN_NETBACK_TX_COPY_LEN &amp;&amp;</div><div class='del'>-			    ret &lt; XEN_NETBK_LEGACY_SLOTS_MAX) ?</div><div class='del'>-			XEN_NETBACK_TX_COPY_LEN : txreq.size;</div><div class='add'>+		if (ret &gt;= XEN_NETBK_LEGACY_SLOTS_MAX - 1 &amp;&amp; data_len &lt; txreq.size)</div><div class='add'>+			data_len = txreq.size;</div><div class='ctx'> </div><div class='ctx'> 		skb = xenvif_alloc_skb(data_len);</div><div class='ctx'> 		if (unlikely(skb == NULL)) {</div><div class='hunk'>@@ -923,8 +996,6 @@ static void xenvif_tx_build_gops(struct xenvif_queue *queue,</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='ctx'> 		skb_shinfo(skb)-&gt;nr_frags = ret;</div><div class='del'>-		if (data_len &lt; txreq.size)</div><div class='del'>-			skb_shinfo(skb)-&gt;nr_frags++;</div><div class='ctx'> 		/* At this point shinfo-&gt;nr_frags is in fact the number of</div><div class='ctx'> 		 * slots, which can be as large as XEN_NETBK_LEGACY_SLOTS_MAX.</div><div class='ctx'> 		 */</div><div class='hunk'>@@ -986,54 +1057,19 @@ static void xenvif_tx_build_gops(struct xenvif_queue *queue,</div><div class='ctx'> 					     type);</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='del'>-		XENVIF_TX_CB(skb)-&gt;pending_idx = pending_idx;</div><div class='del'>-</div><div class='del'>-		__skb_put(skb, data_len);</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].source.u.ref = txreq.gref;</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].source.domid = queue-&gt;vif-&gt;domid;</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].source.offset = txreq.offset;</div><div class='del'>-</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].dest.u.gmfn =</div><div class='del'>-			virt_to_gfn(skb-&gt;data);</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].dest.domid = DOMID_SELF;</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].dest.offset =</div><div class='del'>-			offset_in_page(skb-&gt;data) &amp; ~XEN_PAGE_MASK;</div><div class='del'>-</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].len = data_len;</div><div class='del'>-		queue-&gt;tx_copy_ops[*copy_ops].flags = GNTCOPY_source_gref;</div><div class='del'>-</div><div class='del'>-		(*copy_ops)++;</div><div class='del'>-</div><div class='del'>-		if (data_len &lt; txreq.size) {</div><div class='del'>-			frag_set_pending_idx(&amp;skb_shinfo(skb)-&gt;frags[0],</div><div class='del'>-					     pending_idx);</div><div class='del'>-			xenvif_tx_create_map_op(queue, pending_idx, &amp;txreq,</div><div class='del'>-						extra_count, gop);</div><div class='del'>-			gop++;</div><div class='del'>-		} else {</div><div class='del'>-			frag_set_pending_idx(&amp;skb_shinfo(skb)-&gt;frags[0],</div><div class='del'>-					     INVALID_PENDING_IDX);</div><div class='del'>-			memcpy(&amp;queue-&gt;pending_tx_info[pending_idx].req,</div><div class='del'>-			       &amp;txreq, sizeof(txreq));</div><div class='del'>-			queue-&gt;pending_tx_info[pending_idx].extra_count =</div><div class='del'>-				extra_count;</div><div class='del'>-		}</div><div class='del'>-</div><div class='del'>-		queue-&gt;pending_cons++;</div><div class='del'>-</div><div class='del'>-		gop = xenvif_get_requests(queue, skb, txfrags, gop,</div><div class='del'>-				          frag_overflow, nskb);</div><div class='add'>+		xenvif_get_requests(queue, skb, &amp;txreq, txfrags, copy_ops,</div><div class='add'>+				    map_ops, frag_overflow, nskb, extra_count,</div><div class='add'>+				    data_len);</div><div class='ctx'> </div><div class='ctx'> 		__skb_queue_tail(&amp;queue-&gt;tx_queue, skb);</div><div class='ctx'> </div><div class='ctx'> 		queue-&gt;tx.req_cons = idx;</div><div class='ctx'> </div><div class='del'>-		if (((gop-queue-&gt;tx_map_ops) &gt;= ARRAY_SIZE(queue-&gt;tx_map_ops)) ||</div><div class='add'>+		if ((*map_ops &gt;= ARRAY_SIZE(queue-&gt;tx_map_ops)) ||</div><div class='ctx'> 		    (*copy_ops &gt;= ARRAY_SIZE(queue-&gt;tx_copy_ops)))</div><div class='ctx'> 			break;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	(*map_ops) = gop - queue-&gt;tx_map_ops;</div><div class='ctx'> 	return;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='hunk'>@@ -1112,9 +1148,8 @@ static int xenvif_tx_submit(struct xenvif_queue *queue)</div><div class='ctx'> 	while ((skb = __skb_dequeue(&amp;queue-&gt;tx_queue)) != NULL) {</div><div class='ctx'> 		struct xen_netif_tx_request *txp;</div><div class='ctx'> 		u16 pending_idx;</div><div class='del'>-		unsigned data_len;</div><div class='ctx'> </div><div class='del'>-		pending_idx = XENVIF_TX_CB(skb)-&gt;pending_idx;</div><div class='add'>+		pending_idx = copy_pending_idx(skb, 0);</div><div class='ctx'> 		txp = &amp;queue-&gt;pending_tx_info[pending_idx].req;</div><div class='ctx'> </div><div class='ctx'> 		/* Check the remap error code. */</div><div class='hunk'>@@ -1133,18 +1168,6 @@ static int xenvif_tx_submit(struct xenvif_queue *queue)</div><div class='ctx'> 			continue;</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='del'>-		data_len = skb-&gt;len;</div><div class='del'>-		callback_param(queue, pending_idx).ctx = NULL;</div><div class='del'>-		if (data_len &lt; txp-&gt;size) {</div><div class='del'>-			/* Append the packet payload as a fragment. */</div><div class='del'>-			txp-&gt;offset += data_len;</div><div class='del'>-			txp-&gt;size -= data_len;</div><div class='del'>-		} else {</div><div class='del'>-			/* Schedule a response immediately. */</div><div class='del'>-			xenvif_idx_release(queue, pending_idx,</div><div class='del'>-					   XEN_NETIF_RSP_OKAY);</div><div class='del'>-		}</div><div class='del'>-</div><div class='ctx'> 		if (txp-&gt;flags &amp; XEN_NETTXF_csum_blank)</div><div class='ctx'> 			skb-&gt;ip_summed = CHECKSUM_PARTIAL;</div><div class='ctx'> 		else if (txp-&gt;flags &amp; XEN_NETTXF_data_validated)</div><div class='hunk'>@@ -1331,7 +1354,7 @@ static inline void xenvif_tx_dealloc_action(struct xenvif_queue *queue)</div><div class='ctx'> /* Called after netfront has transmitted */</div><div class='ctx'> int xenvif_tx_action(struct xenvif_queue *queue, int budget)</div><div class='ctx'> {</div><div class='del'>-	unsigned nr_mops, nr_cops = 0;</div><div class='add'>+	unsigned nr_mops = 0, nr_cops = 0;</div><div class='ctx'> 	int work_done, ret;</div><div class='ctx'> </div><div class='ctx'> 	if (unlikely(!tx_work_todo(queue)))</div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit </a> (<a href='https://git-scm.com/'>git 2.34.1</a>) at 2023-02-02 23:01:30 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
