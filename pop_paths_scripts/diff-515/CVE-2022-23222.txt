<!DOCTYPE html>
<html lang='en'>
<head>
<title>kernel/git/torvalds/linux.git - Linux kernel source tree</title>
<meta name='generator' content='cgit '/>
<meta name='robots' content='noindex, nofollow'/>
<link rel='stylesheet' type='text/css' href='/cgit-data/cgit.css'/>
<link rel='shortcut icon' href='/favicon.ico'/>
<link rel='alternate' title='Atom feed' href='http://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/atom/?h=master' type='application/atom+xml'/>
<link rel='vcs-git' href='git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
<link rel='vcs-git' href='https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
<link rel='vcs-git' href='https://kernel.googlesource.com/pub/scm/linux/kernel/git/torvalds/linux.git' title='kernel/git/torvalds/linux.git Git repository'/>
</head>
<body>
<div id='cgit'><table id='header'>
<tr>
<td class='logo' rowspan='2'><a href='/'><img src='/cgit-data/cgit.png' alt='cgit logo'/></a></td>
<td class='main'><a href='/'>index</a> : <a title='kernel/git/torvalds/linux.git' href='/pub/scm/linux/kernel/git/torvalds/linux.git/'>kernel/git/torvalds/linux.git</a></td><td class='form'><form method='get'>
<input type='hidden' name='id' value='8d38cde47a7e17b646401fa92d916503caa5375e'/><select name='h' onchange='this.form.submit();'>
<option value='master' selected='selected'>master</option>
</select> <input type='submit' value='switch'/></form></td></tr>
<tr><td class='sub'>Linux kernel source tree</td><td class='sub right'>Linus Torvalds</td></tr></table>
<table class='tabs'><tr><td>
<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/about/'>about</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/'>summary</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/refs/?id=8d38cde47a7e17b646401fa92d916503caa5375e'>refs</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/log/'>log</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/?id=8d38cde47a7e17b646401fa92d916503caa5375e'>tree</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8d38cde47a7e17b646401fa92d916503caa5375e'>commit</a><a class='active' href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=8d38cde47a7e17b646401fa92d916503caa5375e'>diff</a><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/stats/'>stats</a></td><td class='form'><form class='right' method='get' action='/pub/scm/linux/kernel/git/torvalds/linux.git/log/'>
<input type='hidden' name='id' value='8d38cde47a7e17b646401fa92d916503caa5375e'/><select name='qt'>
<option value='grep'>log msg</option>
<option value='author'>author</option>
<option value='committer'>committer</option>
<option value='range'>range</option>
</select>
<input class='txt' type='search' size='10' name='q' value=''/>
<input type='submit' value='search'/>
</form>
</td></tr></table>
<div class='content'><div class='cgit-panel'><b>diff options</b><form method='get'><input type='hidden' name='id' value='8d38cde47a7e17b646401fa92d916503caa5375e'/><table><tr><td colspan='2'/></tr><tr><td class='label'>context:</td><td class='ctrl'><select name='context' onchange='this.form.submit();'><option value='1'>1</option><option value='2'>2</option><option value='3' selected='selected'>3</option><option value='4'>4</option><option value='5'>5</option><option value='6'>6</option><option value='7'>7</option><option value='8'>8</option><option value='9'>9</option><option value='10'>10</option><option value='15'>15</option><option value='20'>20</option><option value='25'>25</option><option value='30'>30</option><option value='35'>35</option><option value='40'>40</option></select></td></tr><tr><td class='label'>space:</td><td class='ctrl'><select name='ignorews' onchange='this.form.submit();'><option value='0' selected='selected'>include</option><option value='1'>ignore</option></select></td></tr><tr><td class='label'>mode:</td><td class='ctrl'><select name='dt' onchange='this.form.submit();'><option value='0' selected='selected'>unified</option><option value='1'>ssdiff</option><option value='2'>stat only</option></select></td></tr><tr><td/><td class='ctrl'><noscript><input type='submit' value='reload'/></noscript></td></tr></table></form></div><div class='diffstat-header'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/?id=8d38cde47a7e17b646401fa92d916503caa5375e'>Diffstat</a></div><table summary='diffstat' class='diffstat'><tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/bpf.h?id=8d38cde47a7e17b646401fa92d916503caa5375e'>include/linux/bpf.h</a></td><td class='right'>18</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 3.0%;'/><td class='rem' style='width: 3.0%;'/><td class='none' style='width: 93.9%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/include/linux/bpf_verifier.h?id=8d38cde47a7e17b646401fa92d916503caa5375e'>include/linux/bpf_verifier.h</a></td><td class='right'>4</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 1.3%;'/><td class='rem' style='width: 0.0%;'/><td class='none' style='width: 98.7%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/kernel/bpf/btf.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>kernel/bpf/btf.c</a></td><td class='right'>7</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 1.7%;'/><td class='rem' style='width: 0.7%;'/><td class='none' style='width: 97.6%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/kernel/bpf/map_iter.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>kernel/bpf/map_iter.c</a></td><td class='right'>4</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.7%;'/><td class='rem' style='width: 0.7%;'/><td class='none' style='width: 98.7%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/kernel/bpf/verifier.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>kernel/bpf/verifier.c</a></td><td class='right'>297</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 42.4%;'/><td class='rem' style='width: 57.6%;'/><td class='none' style='width: 0.0%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/core/bpf_sk_storage.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>net/core/bpf_sk_storage.c</a></td><td class='right'>2</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.3%;'/><td class='rem' style='width: 0.3%;'/><td class='none' style='width: 99.3%;'/></tr></table></td></tr>
<tr><td class='mode'>-rw-r--r--</td><td class='upd'><a href='/pub/scm/linux/kernel/git/torvalds/linux.git/diff/net/core/sock_map.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>net/core/sock_map.c</a></td><td class='right'>2</td><td class='graph'><table summary='file diffstat' width='100%'><tr><td class='add' style='width: 0.3%;'/><td class='rem' style='width: 0.3%;'/><td class='none' style='width: 99.3%;'/></tr></table></td></tr>
</table><div class='diffstat-summary'>7 files changed, 148 insertions, 186 deletions</div><table summary='diff' class='diff'><tr><td><div class='head'>diff --git a/include/linux/bpf.h b/include/linux/bpf.h<br/>index 31c79271735e1..7249f5e2480ed 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf.h?id=3c141c82b95807473d77079936769e04a84e4ca3'>include/linux/bpf.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf.h?id=8d38cde47a7e17b646401fa92d916503caa5375e'>include/linux/bpf.h</a></div><div class='hunk'>@@ -461,18 +461,15 @@ enum bpf_reg_type {</div><div class='ctx'> 	PTR_TO_CTX,		 /* reg points to bpf_context */</div><div class='ctx'> 	CONST_PTR_TO_MAP,	 /* reg points to struct bpf_map */</div><div class='ctx'> 	PTR_TO_MAP_VALUE,	 /* reg points to map element value */</div><div class='del'>-	PTR_TO_MAP_VALUE_OR_NULL,/* points to map elem value or NULL */</div><div class='add'>+	PTR_TO_MAP_KEY,		 /* reg points to a map element key */</div><div class='ctx'> 	PTR_TO_STACK,		 /* reg == frame_pointer + offset */</div><div class='ctx'> 	PTR_TO_PACKET_META,	 /* skb-&gt;data - meta_len */</div><div class='ctx'> 	PTR_TO_PACKET,		 /* reg points to skb-&gt;data */</div><div class='ctx'> 	PTR_TO_PACKET_END,	 /* skb-&gt;data + headlen */</div><div class='ctx'> 	PTR_TO_FLOW_KEYS,	 /* reg points to bpf_flow_keys */</div><div class='ctx'> 	PTR_TO_SOCKET,		 /* reg points to struct bpf_sock */</div><div class='del'>-	PTR_TO_SOCKET_OR_NULL,	 /* reg points to struct bpf_sock or NULL */</div><div class='ctx'> 	PTR_TO_SOCK_COMMON,	 /* reg points to sock_common */</div><div class='del'>-	PTR_TO_SOCK_COMMON_OR_NULL, /* reg points to sock_common or NULL */</div><div class='ctx'> 	PTR_TO_TCP_SOCK,	 /* reg points to struct tcp_sock */</div><div class='del'>-	PTR_TO_TCP_SOCK_OR_NULL, /* reg points to struct tcp_sock or NULL */</div><div class='ctx'> 	PTR_TO_TP_BUFFER,	 /* reg points to a writable raw tp's buffer */</div><div class='ctx'> 	PTR_TO_XDP_SOCK,	 /* reg points to struct xdp_sock */</div><div class='ctx'> 	/* PTR_TO_BTF_ID points to a kernel struct that does not need</div><div class='hunk'>@@ -490,18 +487,21 @@ enum bpf_reg_type {</div><div class='ctx'> 	 * been checked for null. Used primarily to inform the verifier</div><div class='ctx'> 	 * an explicit null check is required for this struct.</div><div class='ctx'> 	 */</div><div class='del'>-	PTR_TO_BTF_ID_OR_NULL,</div><div class='ctx'> 	PTR_TO_MEM,		 /* reg points to valid memory region */</div><div class='del'>-	PTR_TO_MEM_OR_NULL,	 /* reg points to valid memory region or NULL */</div><div class='ctx'> 	PTR_TO_RDONLY_BUF,	 /* reg points to a readonly buffer */</div><div class='del'>-	PTR_TO_RDONLY_BUF_OR_NULL, /* reg points to a readonly buffer or NULL */</div><div class='ctx'> 	PTR_TO_RDWR_BUF,	 /* reg points to a read/write buffer */</div><div class='del'>-	PTR_TO_RDWR_BUF_OR_NULL, /* reg points to a read/write buffer or NULL */</div><div class='ctx'> 	PTR_TO_PERCPU_BTF_ID,	 /* reg points to a percpu kernel variable */</div><div class='ctx'> 	PTR_TO_FUNC,		 /* reg points to a bpf program function */</div><div class='del'>-	PTR_TO_MAP_KEY,		 /* reg points to a map element key */</div><div class='ctx'> 	__BPF_REG_TYPE_MAX,</div><div class='ctx'> </div><div class='add'>+	/* Extended reg_types. */</div><div class='add'>+	PTR_TO_MAP_VALUE_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_MAP_VALUE,</div><div class='add'>+	PTR_TO_SOCKET_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_SOCKET,</div><div class='add'>+	PTR_TO_SOCK_COMMON_OR_NULL	= PTR_MAYBE_NULL | PTR_TO_SOCK_COMMON,</div><div class='add'>+	PTR_TO_TCP_SOCK_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_TCP_SOCK,</div><div class='add'>+	PTR_TO_BTF_ID_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_BTF_ID,</div><div class='add'>+	PTR_TO_MEM_OR_NULL		= PTR_MAYBE_NULL | PTR_TO_MEM,</div><div class='add'>+</div><div class='ctx'> 	/* This must be the last entry. Its purpose is to ensure the enum is</div><div class='ctx'> 	 * wide enough to hold the higher bits reserved for bpf_type_flag.</div><div class='ctx'> 	 */</div><div class='head'>diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h<br/>index 2e612f3fd3856..bb1cc3fbc4bab 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf_verifier.h?id=3c141c82b95807473d77079936769e04a84e4ca3'>include/linux/bpf_verifier.h</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf_verifier.h?id=8d38cde47a7e17b646401fa92d916503caa5375e'>include/linux/bpf_verifier.h</a></div><div class='hunk'>@@ -18,6 +18,8 @@</div><div class='ctx'>  * that converting umax_value to int cannot overflow.</div><div class='ctx'>  */</div><div class='ctx'> #define BPF_MAX_VAR_SIZ	(1 &lt;&lt; 29)</div><div class='add'>+/* size of type_str_buf in bpf_verifier. */</div><div class='add'>+#define TYPE_STR_BUF_LEN 64</div><div class='ctx'> </div><div class='ctx'> /* Liveness marks, used for registers and spilled-regs (in stack slots).</div><div class='ctx'>  * Read marks propagate upwards until they find a write mark; they record that</div><div class='hunk'>@@ -474,6 +476,8 @@ struct bpf_verifier_env {</div><div class='ctx'> 	/* longest register parentage chain walked for liveness marking */</div><div class='ctx'> 	u32 longest_mark_read_walk;</div><div class='ctx'> 	bpfptr_t fd_array;</div><div class='add'>+	/* buffer used in reg_type_str() to generate reg_type string */</div><div class='add'>+	char type_str_buf[TYPE_STR_BUF_LEN];</div><div class='ctx'> };</div><div class='ctx'> </div><div class='ctx'> __printf(2, 0) void bpf_verifier_vlog(struct bpf_verifier_log *log,</div><div class='head'>diff --git a/kernel/bpf/btf.c b/kernel/bpf/btf.c<br/>index 09406b0e215e1..1872b3e05d6c6 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/btf.c?id=3c141c82b95807473d77079936769e04a84e4ca3'>kernel/bpf/btf.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/btf.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>kernel/bpf/btf.c</a></div><div class='hunk'>@@ -4800,10 +4800,13 @@ bool btf_ctx_access(int off, int size, enum bpf_access_type type,</div><div class='ctx'> 	/* check for PTR_TO_RDONLY_BUF_OR_NULL or PTR_TO_RDWR_BUF_OR_NULL */</div><div class='ctx'> 	for (i = 0; i &lt; prog-&gt;aux-&gt;ctx_arg_info_size; i++) {</div><div class='ctx'> 		const struct bpf_ctx_arg_aux *ctx_arg_info = &amp;prog-&gt;aux-&gt;ctx_arg_info[i];</div><div class='add'>+		u32 type, flag;</div><div class='ctx'> </div><div class='add'>+		type = base_type(ctx_arg_info-&gt;reg_type);</div><div class='add'>+		flag = type_flag(ctx_arg_info-&gt;reg_type);</div><div class='ctx'> 		if (ctx_arg_info-&gt;offset == off &amp;&amp;</div><div class='del'>-		    (ctx_arg_info-&gt;reg_type == PTR_TO_RDONLY_BUF_OR_NULL ||</div><div class='del'>-		     ctx_arg_info-&gt;reg_type == PTR_TO_RDWR_BUF_OR_NULL)) {</div><div class='add'>+		    (type == PTR_TO_RDWR_BUF || type == PTR_TO_RDONLY_BUF) &amp;&amp;</div><div class='add'>+		    (flag &amp; PTR_MAYBE_NULL)) {</div><div class='ctx'> 			info-&gt;reg_type = ctx_arg_info-&gt;reg_type;</div><div class='ctx'> 			return true;</div><div class='ctx'> 		}</div><div class='head'>diff --git a/kernel/bpf/map_iter.c b/kernel/bpf/map_iter.c<br/>index 6a9542af4212a..631f0e44b7a9e 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/map_iter.c?id=3c141c82b95807473d77079936769e04a84e4ca3'>kernel/bpf/map_iter.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/map_iter.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>kernel/bpf/map_iter.c</a></div><div class='hunk'>@@ -174,9 +174,9 @@ static const struct bpf_iter_reg bpf_map_elem_reg_info = {</div><div class='ctx'> 	.ctx_arg_info_size	= 2,</div><div class='ctx'> 	.ctx_arg_info		= {</div><div class='ctx'> 		{ offsetof(struct bpf_iter__bpf_map_elem, key),</div><div class='del'>-		  PTR_TO_RDONLY_BUF_OR_NULL },</div><div class='add'>+		  PTR_TO_RDONLY_BUF | PTR_MAYBE_NULL },</div><div class='ctx'> 		{ offsetof(struct bpf_iter__bpf_map_elem, value),</div><div class='del'>-		  PTR_TO_RDWR_BUF_OR_NULL },</div><div class='add'>+		  PTR_TO_RDWR_BUF | PTR_MAYBE_NULL },</div><div class='ctx'> 	},</div><div class='ctx'> };</div><div class='ctx'> </div><div class='head'>diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c<br/>index 647a7c4b8da90..24e9955a93e52 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/verifier.c?id=3c141c82b95807473d77079936769e04a84e4ca3'>kernel/bpf/verifier.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf/verifier.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>kernel/bpf/verifier.c</a></div><div class='hunk'>@@ -445,18 +445,6 @@ static bool reg_type_not_null(enum bpf_reg_type type)</div><div class='ctx'> 		type == PTR_TO_SOCK_COMMON;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-static bool reg_type_may_be_null(enum bpf_reg_type type)</div><div class='del'>-{</div><div class='del'>-	return type == PTR_TO_MAP_VALUE_OR_NULL ||</div><div class='del'>-	       type == PTR_TO_SOCKET_OR_NULL ||</div><div class='del'>-	       type == PTR_TO_SOCK_COMMON_OR_NULL ||</div><div class='del'>-	       type == PTR_TO_TCP_SOCK_OR_NULL ||</div><div class='del'>-	       type == PTR_TO_BTF_ID_OR_NULL ||</div><div class='del'>-	       type == PTR_TO_MEM_OR_NULL ||</div><div class='del'>-	       type == PTR_TO_RDONLY_BUF_OR_NULL ||</div><div class='del'>-	       type == PTR_TO_RDWR_BUF_OR_NULL;</div><div class='del'>-}</div><div class='del'>-</div><div class='ctx'> static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)</div><div class='ctx'> {</div><div class='ctx'> 	return reg-&gt;type == PTR_TO_MAP_VALUE &amp;&amp;</div><div class='hunk'>@@ -465,12 +453,9 @@ static bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)</div><div class='ctx'> </div><div class='ctx'> static bool reg_type_may_be_refcounted_or_null(enum bpf_reg_type type)</div><div class='ctx'> {</div><div class='del'>-	return type == PTR_TO_SOCKET ||</div><div class='del'>-		type == PTR_TO_SOCKET_OR_NULL ||</div><div class='del'>-		type == PTR_TO_TCP_SOCK ||</div><div class='del'>-		type == PTR_TO_TCP_SOCK_OR_NULL ||</div><div class='del'>-		type == PTR_TO_MEM ||</div><div class='del'>-		type == PTR_TO_MEM_OR_NULL;</div><div class='add'>+	return base_type(type) == PTR_TO_SOCKET ||</div><div class='add'>+		base_type(type) == PTR_TO_TCP_SOCK ||</div><div class='add'>+		base_type(type) == PTR_TO_MEM;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> static bool arg_type_may_be_refcounted(enum bpf_arg_type type)</div><div class='hunk'>@@ -540,39 +525,52 @@ static bool is_cmpxchg_insn(const struct bpf_insn *insn)</div><div class='ctx'> 	       insn-&gt;imm == BPF_CMPXCHG;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='del'>-/* string representation of 'enum bpf_reg_type' */</div><div class='del'>-static const char * const reg_type_str[] = {</div><div class='del'>-	[NOT_INIT]		= "?",</div><div class='del'>-	[SCALAR_VALUE]		= "inv",</div><div class='del'>-	[PTR_TO_CTX]		= "ctx",</div><div class='del'>-	[CONST_PTR_TO_MAP]	= "map_ptr",</div><div class='del'>-	[PTR_TO_MAP_VALUE]	= "map_value",</div><div class='del'>-	[PTR_TO_MAP_VALUE_OR_NULL] = "map_value_or_null",</div><div class='del'>-	[PTR_TO_STACK]		= "fp",</div><div class='del'>-	[PTR_TO_PACKET]		= "pkt",</div><div class='del'>-	[PTR_TO_PACKET_META]	= "pkt_meta",</div><div class='del'>-	[PTR_TO_PACKET_END]	= "pkt_end",</div><div class='del'>-	[PTR_TO_FLOW_KEYS]	= "flow_keys",</div><div class='del'>-	[PTR_TO_SOCKET]		= "sock",</div><div class='del'>-	[PTR_TO_SOCKET_OR_NULL] = "sock_or_null",</div><div class='del'>-	[PTR_TO_SOCK_COMMON]	= "sock_common",</div><div class='del'>-	[PTR_TO_SOCK_COMMON_OR_NULL] = "sock_common_or_null",</div><div class='del'>-	[PTR_TO_TCP_SOCK]	= "tcp_sock",</div><div class='del'>-	[PTR_TO_TCP_SOCK_OR_NULL] = "tcp_sock_or_null",</div><div class='del'>-	[PTR_TO_TP_BUFFER]	= "tp_buffer",</div><div class='del'>-	[PTR_TO_XDP_SOCK]	= "xdp_sock",</div><div class='del'>-	[PTR_TO_BTF_ID]		= "ptr_",</div><div class='del'>-	[PTR_TO_BTF_ID_OR_NULL]	= "ptr_or_null_",</div><div class='del'>-	[PTR_TO_PERCPU_BTF_ID]	= "percpu_ptr_",</div><div class='del'>-	[PTR_TO_MEM]		= "mem",</div><div class='del'>-	[PTR_TO_MEM_OR_NULL]	= "mem_or_null",</div><div class='del'>-	[PTR_TO_RDONLY_BUF]	= "rdonly_buf",</div><div class='del'>-	[PTR_TO_RDONLY_BUF_OR_NULL] = "rdonly_buf_or_null",</div><div class='del'>-	[PTR_TO_RDWR_BUF]	= "rdwr_buf",</div><div class='del'>-	[PTR_TO_RDWR_BUF_OR_NULL] = "rdwr_buf_or_null",</div><div class='del'>-	[PTR_TO_FUNC]		= "func",</div><div class='del'>-	[PTR_TO_MAP_KEY]	= "map_key",</div><div class='del'>-};</div><div class='add'>+/* string representation of 'enum bpf_reg_type'</div><div class='add'>+ *</div><div class='add'>+ * Note that reg_type_str() can not appear more than once in a single verbose()</div><div class='add'>+ * statement.</div><div class='add'>+ */</div><div class='add'>+static const char *reg_type_str(struct bpf_verifier_env *env,</div><div class='add'>+				enum bpf_reg_type type)</div><div class='add'>+{</div><div class='add'>+	char postfix[16] = {0};</div><div class='add'>+	static const char * const str[] = {</div><div class='add'>+		[NOT_INIT]		= "?",</div><div class='add'>+		[SCALAR_VALUE]		= "inv",</div><div class='add'>+		[PTR_TO_CTX]		= "ctx",</div><div class='add'>+		[CONST_PTR_TO_MAP]	= "map_ptr",</div><div class='add'>+		[PTR_TO_MAP_VALUE]	= "map_value",</div><div class='add'>+		[PTR_TO_STACK]		= "fp",</div><div class='add'>+		[PTR_TO_PACKET]		= "pkt",</div><div class='add'>+		[PTR_TO_PACKET_META]	= "pkt_meta",</div><div class='add'>+		[PTR_TO_PACKET_END]	= "pkt_end",</div><div class='add'>+		[PTR_TO_FLOW_KEYS]	= "flow_keys",</div><div class='add'>+		[PTR_TO_SOCKET]		= "sock",</div><div class='add'>+		[PTR_TO_SOCK_COMMON]	= "sock_common",</div><div class='add'>+		[PTR_TO_TCP_SOCK]	= "tcp_sock",</div><div class='add'>+		[PTR_TO_TP_BUFFER]	= "tp_buffer",</div><div class='add'>+		[PTR_TO_XDP_SOCK]	= "xdp_sock",</div><div class='add'>+		[PTR_TO_BTF_ID]		= "ptr_",</div><div class='add'>+		[PTR_TO_PERCPU_BTF_ID]	= "percpu_ptr_",</div><div class='add'>+		[PTR_TO_MEM]		= "mem",</div><div class='add'>+		[PTR_TO_RDONLY_BUF]	= "rdonly_buf",</div><div class='add'>+		[PTR_TO_RDWR_BUF]	= "rdwr_buf",</div><div class='add'>+		[PTR_TO_FUNC]		= "func",</div><div class='add'>+		[PTR_TO_MAP_KEY]	= "map_key",</div><div class='add'>+	};</div><div class='add'>+</div><div class='add'>+	if (type &amp; PTR_MAYBE_NULL) {</div><div class='add'>+		if (base_type(type) == PTR_TO_BTF_ID ||</div><div class='add'>+		    base_type(type) == PTR_TO_PERCPU_BTF_ID)</div><div class='add'>+			strncpy(postfix, "or_null_", 16);</div><div class='add'>+		else</div><div class='add'>+			strncpy(postfix, "_or_null", 16);</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	snprintf(env-&gt;type_str_buf, TYPE_STR_BUF_LEN, "%s%s",</div><div class='add'>+		 str[base_type(type)], postfix);</div><div class='add'>+	return env-&gt;type_str_buf;</div><div class='add'>+}</div><div class='ctx'> </div><div class='ctx'> static char slot_type_char[] = {</div><div class='ctx'> 	[STACK_INVALID]	= '?',</div><div class='hunk'>@@ -623,7 +621,7 @@ static void print_verifier_state(struct bpf_verifier_env *env,</div><div class='ctx'> 			continue;</div><div class='ctx'> 		verbose(env, " R%d", i);</div><div class='ctx'> 		print_liveness(env, reg-&gt;live);</div><div class='del'>-		verbose(env, "=%s", reg_type_str[t]);</div><div class='add'>+		verbose(env, "=%s", reg_type_str(env, t));</div><div class='ctx'> 		if (t == SCALAR_VALUE &amp;&amp; reg-&gt;precise)</div><div class='ctx'> 			verbose(env, "P");</div><div class='ctx'> 		if ((t == SCALAR_VALUE || t == PTR_TO_STACK) &amp;&amp;</div><div class='hunk'>@@ -631,9 +629,8 @@ static void print_verifier_state(struct bpf_verifier_env *env,</div><div class='ctx'> 			/* reg-&gt;off should be 0 for SCALAR_VALUE */</div><div class='ctx'> 			verbose(env, "%lld", reg-&gt;var_off.value + reg-&gt;off);</div><div class='ctx'> 		} else {</div><div class='del'>-			if (t == PTR_TO_BTF_ID ||</div><div class='del'>-			    t == PTR_TO_BTF_ID_OR_NULL ||</div><div class='del'>-			    t == PTR_TO_PERCPU_BTF_ID)</div><div class='add'>+			if (base_type(t) == PTR_TO_BTF_ID ||</div><div class='add'>+			    base_type(t) == PTR_TO_PERCPU_BTF_ID)</div><div class='ctx'> 				verbose(env, "%s", kernel_type_name(reg-&gt;btf, reg-&gt;btf_id));</div><div class='ctx'> 			verbose(env, "(id=%d", reg-&gt;id);</div><div class='ctx'> 			if (reg_type_may_be_refcounted_or_null(t))</div><div class='hunk'>@@ -642,10 +639,9 @@ static void print_verifier_state(struct bpf_verifier_env *env,</div><div class='ctx'> 				verbose(env, ",off=%d", reg-&gt;off);</div><div class='ctx'> 			if (type_is_pkt_pointer(t))</div><div class='ctx'> 				verbose(env, ",r=%d", reg-&gt;range);</div><div class='del'>-			else if (t == CONST_PTR_TO_MAP ||</div><div class='del'>-				 t == PTR_TO_MAP_KEY ||</div><div class='del'>-				 t == PTR_TO_MAP_VALUE ||</div><div class='del'>-				 t == PTR_TO_MAP_VALUE_OR_NULL)</div><div class='add'>+			else if (base_type(t) == CONST_PTR_TO_MAP ||</div><div class='add'>+				 base_type(t) == PTR_TO_MAP_KEY ||</div><div class='add'>+				 base_type(t) == PTR_TO_MAP_VALUE)</div><div class='ctx'> 				verbose(env, ",ks=%d,vs=%d",</div><div class='ctx'> 					reg-&gt;map_ptr-&gt;key_size,</div><div class='ctx'> 					reg-&gt;map_ptr-&gt;value_size);</div><div class='hunk'>@@ -715,7 +711,7 @@ static void print_verifier_state(struct bpf_verifier_env *env,</div><div class='ctx'> 		if (state-&gt;stack[i].slot_type[0] == STACK_SPILL) {</div><div class='ctx'> 			reg = &amp;state-&gt;stack[i].spilled_ptr;</div><div class='ctx'> 			t = reg-&gt;type;</div><div class='del'>-			verbose(env, "=%s", reg_type_str[t]);</div><div class='add'>+			verbose(env, "=%s", reg_type_str(env, t));</div><div class='ctx'> 			if (t == SCALAR_VALUE &amp;&amp; reg-&gt;precise)</div><div class='ctx'> 				verbose(env, "P");</div><div class='ctx'> 			if (t == SCALAR_VALUE &amp;&amp; tnum_is_const(reg-&gt;var_off))</div><div class='hunk'>@@ -1128,8 +1124,7 @@ static void mark_reg_known_zero(struct bpf_verifier_env *env,</div><div class='ctx'> </div><div class='ctx'> static void mark_ptr_not_null_reg(struct bpf_reg_state *reg)</div><div class='ctx'> {</div><div class='del'>-	switch (reg-&gt;type) {</div><div class='del'>-	case PTR_TO_MAP_VALUE_OR_NULL: {</div><div class='add'>+	if (base_type(reg-&gt;type) == PTR_TO_MAP_VALUE) {</div><div class='ctx'> 		const struct bpf_map *map = reg-&gt;map_ptr;</div><div class='ctx'> </div><div class='ctx'> 		if (map-&gt;inner_map_meta) {</div><div class='hunk'>@@ -1148,32 +1143,10 @@ static void mark_ptr_not_null_reg(struct bpf_reg_state *reg)</div><div class='ctx'> 		} else {</div><div class='ctx'> 			reg-&gt;type = PTR_TO_MAP_VALUE;</div><div class='ctx'> 		}</div><div class='del'>-		break;</div><div class='del'>-	}</div><div class='del'>-	case PTR_TO_SOCKET_OR_NULL:</div><div class='del'>-		reg-&gt;type = PTR_TO_SOCKET;</div><div class='del'>-		break;</div><div class='del'>-	case PTR_TO_SOCK_COMMON_OR_NULL:</div><div class='del'>-		reg-&gt;type = PTR_TO_SOCK_COMMON;</div><div class='del'>-		break;</div><div class='del'>-	case PTR_TO_TCP_SOCK_OR_NULL:</div><div class='del'>-		reg-&gt;type = PTR_TO_TCP_SOCK;</div><div class='del'>-		break;</div><div class='del'>-	case PTR_TO_BTF_ID_OR_NULL:</div><div class='del'>-		reg-&gt;type = PTR_TO_BTF_ID;</div><div class='del'>-		break;</div><div class='del'>-	case PTR_TO_MEM_OR_NULL:</div><div class='del'>-		reg-&gt;type = PTR_TO_MEM;</div><div class='del'>-		break;</div><div class='del'>-	case PTR_TO_RDONLY_BUF_OR_NULL:</div><div class='del'>-		reg-&gt;type = PTR_TO_RDONLY_BUF;</div><div class='del'>-		break;</div><div class='del'>-	case PTR_TO_RDWR_BUF_OR_NULL:</div><div class='del'>-		reg-&gt;type = PTR_TO_RDWR_BUF;</div><div class='del'>-		break;</div><div class='del'>-	default:</div><div class='del'>-		WARN_ONCE(1, "unknown nullable register type");</div><div class='add'>+		return;</div><div class='ctx'> 	}</div><div class='add'>+</div><div class='add'>+	reg-&gt;type &amp;= ~PTR_MAYBE_NULL;</div><div class='ctx'> }</div><div class='ctx'> </div><div class='ctx'> static bool reg_is_pkt_pointer(const struct bpf_reg_state *reg)</div><div class='hunk'>@@ -1901,7 +1874,7 @@ static int mark_reg_read(struct bpf_verifier_env *env,</div><div class='ctx'> 			break;</div><div class='ctx'> 		if (parent-&gt;live &amp; REG_LIVE_DONE) {</div><div class='ctx'> 			verbose(env, "verifier BUG type %s var_off %lld off %d\n",</div><div class='del'>-				reg_type_str[parent-&gt;type],</div><div class='add'>+				reg_type_str(env, parent-&gt;type),</div><div class='ctx'> 				parent-&gt;var_off.value, parent-&gt;off);</div><div class='ctx'> 			return -EFAULT;</div><div class='ctx'> 		}</div><div class='hunk'>@@ -2559,9 +2532,8 @@ static int mark_chain_precision_stack(struct bpf_verifier_env *env, int spi)</div><div class='ctx'> </div><div class='ctx'> static bool is_spillable_regtype(enum bpf_reg_type type)</div><div class='ctx'> {</div><div class='del'>-	switch (type) {</div><div class='add'>+	switch (base_type(type)) {</div><div class='ctx'> 	case PTR_TO_MAP_VALUE:</div><div class='del'>-	case PTR_TO_MAP_VALUE_OR_NULL:</div><div class='ctx'> 	case PTR_TO_STACK:</div><div class='ctx'> 	case PTR_TO_CTX:</div><div class='ctx'> 	case PTR_TO_PACKET:</div><div class='hunk'>@@ -2570,21 +2542,14 @@ static bool is_spillable_regtype(enum bpf_reg_type type)</div><div class='ctx'> 	case PTR_TO_FLOW_KEYS:</div><div class='ctx'> 	case CONST_PTR_TO_MAP:</div><div class='ctx'> 	case PTR_TO_SOCKET:</div><div class='del'>-	case PTR_TO_SOCKET_OR_NULL:</div><div class='ctx'> 	case PTR_TO_SOCK_COMMON:</div><div class='del'>-	case PTR_TO_SOCK_COMMON_OR_NULL:</div><div class='ctx'> 	case PTR_TO_TCP_SOCK:</div><div class='del'>-	case PTR_TO_TCP_SOCK_OR_NULL:</div><div class='ctx'> 	case PTR_TO_XDP_SOCK:</div><div class='ctx'> 	case PTR_TO_BTF_ID:</div><div class='del'>-	case PTR_TO_BTF_ID_OR_NULL:</div><div class='ctx'> 	case PTR_TO_RDONLY_BUF:</div><div class='del'>-	case PTR_TO_RDONLY_BUF_OR_NULL:</div><div class='ctx'> 	case PTR_TO_RDWR_BUF:</div><div class='del'>-	case PTR_TO_RDWR_BUF_OR_NULL:</div><div class='ctx'> 	case PTR_TO_PERCPU_BTF_ID:</div><div class='ctx'> 	case PTR_TO_MEM:</div><div class='del'>-	case PTR_TO_MEM_OR_NULL:</div><div class='ctx'> 	case PTR_TO_FUNC:</div><div class='ctx'> 	case PTR_TO_MAP_KEY:</div><div class='ctx'> 		return true;</div><div class='hunk'>@@ -3400,7 +3365,7 @@ static int check_ctx_access(struct bpf_verifier_env *env, int insn_idx, int off,</div><div class='ctx'> 		 */</div><div class='ctx'> 		*reg_type = info.reg_type;</div><div class='ctx'> </div><div class='del'>-		if (*reg_type == PTR_TO_BTF_ID || *reg_type == PTR_TO_BTF_ID_OR_NULL) {</div><div class='add'>+		if (base_type(*reg_type) == PTR_TO_BTF_ID) {</div><div class='ctx'> 			*btf = info.btf;</div><div class='ctx'> 			*btf_id = info.btf_id;</div><div class='ctx'> 		} else {</div><div class='hunk'>@@ -3468,7 +3433,7 @@ static int check_sock_access(struct bpf_verifier_env *env, int insn_idx,</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> 	verbose(env, "R%d invalid %s access off=%d size=%d\n",</div><div class='del'>-		regno, reg_type_str[reg-&gt;type], off, size);</div><div class='add'>+		regno, reg_type_str(env, reg-&gt;type), off, size);</div><div class='ctx'> </div><div class='ctx'> 	return -EACCES;</div><div class='ctx'> }</div><div class='hunk'>@@ -4233,7 +4198,7 @@ static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regn</div><div class='ctx'> 			} else {</div><div class='ctx'> 				mark_reg_known_zero(env, regs,</div><div class='ctx'> 						    value_regno);</div><div class='del'>-				if (reg_type_may_be_null(reg_type))</div><div class='add'>+				if (type_may_be_null(reg_type))</div><div class='ctx'> 					regs[value_regno].id = ++env-&gt;id_gen;</div><div class='ctx'> 				/* A load of ctx field could have different</div><div class='ctx'> 				 * actual load size with the one encoded in the</div><div class='hunk'>@@ -4241,8 +4206,7 @@ static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regn</div><div class='ctx'> 				 * a sub-register.</div><div class='ctx'> 				 */</div><div class='ctx'> 				regs[value_regno].subreg_def = DEF_NOT_SUBREG;</div><div class='del'>-				if (reg_type == PTR_TO_BTF_ID ||</div><div class='del'>-				    reg_type == PTR_TO_BTF_ID_OR_NULL) {</div><div class='add'>+				if (base_type(reg_type) == PTR_TO_BTF_ID) {</div><div class='ctx'> 					regs[value_regno].btf = btf;</div><div class='ctx'> 					regs[value_regno].btf_id = btf_id;</div><div class='ctx'> 				}</div><div class='hunk'>@@ -4295,7 +4259,7 @@ static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regn</div><div class='ctx'> 	} else if (type_is_sk_pointer(reg-&gt;type)) {</div><div class='ctx'> 		if (t == BPF_WRITE) {</div><div class='ctx'> 			verbose(env, "R%d cannot write into %s\n",</div><div class='del'>-				regno, reg_type_str[reg-&gt;type]);</div><div class='add'>+				regno, reg_type_str(env, reg-&gt;type));</div><div class='ctx'> 			return -EACCES;</div><div class='ctx'> 		}</div><div class='ctx'> 		err = check_sock_access(env, insn_idx, regno, off, size, t);</div><div class='hunk'>@@ -4314,7 +4278,7 @@ static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regn</div><div class='ctx'> 	} else if (reg-&gt;type == PTR_TO_RDONLY_BUF) {</div><div class='ctx'> 		if (t == BPF_WRITE) {</div><div class='ctx'> 			verbose(env, "R%d cannot write into %s\n",</div><div class='del'>-				regno, reg_type_str[reg-&gt;type]);</div><div class='add'>+				regno, reg_type_str(env, reg-&gt;type));</div><div class='ctx'> 			return -EACCES;</div><div class='ctx'> 		}</div><div class='ctx'> 		err = check_buffer_access(env, reg, regno, off, size, false,</div><div class='hunk'>@@ -4330,7 +4294,7 @@ static int check_mem_access(struct bpf_verifier_env *env, int insn_idx, u32 regn</div><div class='ctx'> 			mark_reg_unknown(env, regs, value_regno);</div><div class='ctx'> 	} else {</div><div class='ctx'> 		verbose(env, "R%d invalid mem access '%s'\n", regno,</div><div class='del'>-			reg_type_str[reg-&gt;type]);</div><div class='add'>+			reg_type_str(env, reg-&gt;type));</div><div class='ctx'> 		return -EACCES;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='hunk'>@@ -4404,7 +4368,7 @@ static int check_atomic(struct bpf_verifier_env *env, int insn_idx, struct bpf_i</div><div class='ctx'> 	    is_sk_reg(env, insn-&gt;dst_reg)) {</div><div class='ctx'> 		verbose(env, "BPF_ATOMIC stores into R%d %s is not allowed\n",</div><div class='ctx'> 			insn-&gt;dst_reg,</div><div class='del'>-			reg_type_str[reg_state(env, insn-&gt;dst_reg)-&gt;type]);</div><div class='add'>+			reg_type_str(env, reg_state(env, insn-&gt;dst_reg)-&gt;type));</div><div class='ctx'> 		return -EACCES;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='hunk'>@@ -4630,9 +4594,9 @@ static int check_helper_mem_access(struct bpf_verifier_env *env, int regno,</div><div class='ctx'> 		    register_is_null(reg))</div><div class='ctx'> 			return 0;</div><div class='ctx'> </div><div class='del'>-		verbose(env, "R%d type=%s expected=%s\n", regno,</div><div class='del'>-			reg_type_str[reg-&gt;type],</div><div class='del'>-			reg_type_str[PTR_TO_STACK]);</div><div class='add'>+		verbose(env, "R%d type=%s ", regno,</div><div class='add'>+			reg_type_str(env, reg-&gt;type));</div><div class='add'>+		verbose(env, "expected=%s\n", reg_type_str(env, PTR_TO_STACK));</div><div class='ctx'> 		return -EACCES;</div><div class='ctx'> 	}</div><div class='ctx'> }</div><div class='hunk'>@@ -4643,7 +4607,7 @@ int check_mem_reg(struct bpf_verifier_env *env, struct bpf_reg_state *reg,</div><div class='ctx'> 	if (register_is_null(reg))</div><div class='ctx'> 		return 0;</div><div class='ctx'> </div><div class='del'>-	if (reg_type_may_be_null(reg-&gt;type)) {</div><div class='add'>+	if (type_may_be_null(reg-&gt;type)) {</div><div class='ctx'> 		/* Assuming that the register contains a value check if the memory</div><div class='ctx'> 		 * access is safe. Temporarily save and restore the register's state as</div><div class='ctx'> 		 * the conversion shouldn't be visible to a caller.</div><div class='hunk'>@@ -4974,10 +4938,10 @@ static int check_reg_type(struct bpf_verifier_env *env, u32 regno,</div><div class='ctx'> 			goto found;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	verbose(env, "R%d type=%s expected=", regno, reg_type_str[type]);</div><div class='add'>+	verbose(env, "R%d type=%s expected=", regno, reg_type_str(env, type));</div><div class='ctx'> 	for (j = 0; j + 1 &lt; i; j++)</div><div class='del'>-		verbose(env, "%s, ", reg_type_str[compatible-&gt;types[j]]);</div><div class='del'>-	verbose(env, "%s\n", reg_type_str[compatible-&gt;types[j]]);</div><div class='add'>+		verbose(env, "%s, ", reg_type_str(env, compatible-&gt;types[j]));</div><div class='add'>+	verbose(env, "%s\n", reg_type_str(env, compatible-&gt;types[j]));</div><div class='ctx'> 	return -EACCES;</div><div class='ctx'> </div><div class='ctx'> found:</div><div class='hunk'>@@ -6196,6 +6160,7 @@ static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn</div><div class='ctx'> {</div><div class='ctx'> 	const struct bpf_func_proto *fn = NULL;</div><div class='ctx'> 	enum bpf_return_type ret_type;</div><div class='add'>+	enum bpf_type_flag ret_flag;</div><div class='ctx'> 	struct bpf_reg_state *regs;</div><div class='ctx'> 	struct bpf_call_arg_meta meta;</div><div class='ctx'> 	int insn_idx = *insn_idx_p;</div><div class='hunk'>@@ -6330,6 +6295,7 @@ static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn</div><div class='ctx'> </div><div class='ctx'> 	/* update return register (already marked as written above) */</div><div class='ctx'> 	ret_type = fn-&gt;ret_type;</div><div class='add'>+	ret_flag = type_flag(fn-&gt;ret_type);</div><div class='ctx'> 	if (ret_type == RET_INTEGER) {</div><div class='ctx'> 		/* sets type to SCALAR_VALUE */</div><div class='ctx'> 		mark_reg_unknown(env, regs, BPF_REG_0);</div><div class='hunk'>@@ -6349,25 +6315,23 @@ static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn</div><div class='ctx'> 		}</div><div class='ctx'> 		regs[BPF_REG_0].map_ptr = meta.map_ptr;</div><div class='ctx'> 		regs[BPF_REG_0].map_uid = meta.map_uid;</div><div class='del'>-		if (type_may_be_null(ret_type)) {</div><div class='del'>-			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;</div><div class='del'>-		} else {</div><div class='del'>-			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE;</div><div class='del'>-			if (map_value_has_spin_lock(meta.map_ptr))</div><div class='del'>-				regs[BPF_REG_0].id = ++env-&gt;id_gen;</div><div class='add'>+		regs[BPF_REG_0].type = PTR_TO_MAP_VALUE | ret_flag;</div><div class='add'>+		if (!type_may_be_null(ret_type) &amp;&amp;</div><div class='add'>+		    map_value_has_spin_lock(meta.map_ptr)) {</div><div class='add'>+			regs[BPF_REG_0].id = ++env-&gt;id_gen;</div><div class='ctx'> 		}</div><div class='ctx'> 	} else if (base_type(ret_type) == RET_PTR_TO_SOCKET) {</div><div class='ctx'> 		mark_reg_known_zero(env, regs, BPF_REG_0);</div><div class='del'>-		regs[BPF_REG_0].type = PTR_TO_SOCKET_OR_NULL;</div><div class='add'>+		regs[BPF_REG_0].type = PTR_TO_SOCKET | ret_flag;</div><div class='ctx'> 	} else if (base_type(ret_type) == RET_PTR_TO_SOCK_COMMON) {</div><div class='ctx'> 		mark_reg_known_zero(env, regs, BPF_REG_0);</div><div class='del'>-		regs[BPF_REG_0].type = PTR_TO_SOCK_COMMON_OR_NULL;</div><div class='add'>+		regs[BPF_REG_0].type = PTR_TO_SOCK_COMMON | ret_flag;</div><div class='ctx'> 	} else if (base_type(ret_type) == RET_PTR_TO_TCP_SOCK) {</div><div class='ctx'> 		mark_reg_known_zero(env, regs, BPF_REG_0);</div><div class='del'>-		regs[BPF_REG_0].type = PTR_TO_TCP_SOCK_OR_NULL;</div><div class='add'>+		regs[BPF_REG_0].type = PTR_TO_TCP_SOCK | ret_flag;</div><div class='ctx'> 	} else if (base_type(ret_type) == RET_PTR_TO_ALLOC_MEM) {</div><div class='ctx'> 		mark_reg_known_zero(env, regs, BPF_REG_0);</div><div class='del'>-		regs[BPF_REG_0].type = PTR_TO_MEM_OR_NULL;</div><div class='add'>+		regs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;</div><div class='ctx'> 		regs[BPF_REG_0].mem_size = meta.mem_size;</div><div class='ctx'> 	} else if (base_type(ret_type) == RET_PTR_TO_MEM_OR_BTF_ID) {</div><div class='ctx'> 		const struct btf_type *t;</div><div class='hunk'>@@ -6387,14 +6351,10 @@ static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn</div><div class='ctx'> 					tname, PTR_ERR(ret));</div><div class='ctx'> 				return -EINVAL;</div><div class='ctx'> 			}</div><div class='del'>-			regs[BPF_REG_0].type =</div><div class='del'>-				(ret_type &amp; PTR_MAYBE_NULL) ?</div><div class='del'>-				PTR_TO_MEM_OR_NULL : PTR_TO_MEM;</div><div class='add'>+			regs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;</div><div class='ctx'> 			regs[BPF_REG_0].mem_size = tsize;</div><div class='ctx'> 		} else {</div><div class='del'>-			regs[BPF_REG_0].type =</div><div class='del'>-				(ret_type &amp; PTR_MAYBE_NULL) ?</div><div class='del'>-				PTR_TO_BTF_ID_OR_NULL : PTR_TO_BTF_ID;</div><div class='add'>+			regs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;</div><div class='ctx'> 			regs[BPF_REG_0].btf = meta.ret_btf;</div><div class='ctx'> 			regs[BPF_REG_0].btf_id = meta.ret_btf_id;</div><div class='ctx'> 		}</div><div class='hunk'>@@ -6402,9 +6362,7 @@ static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn</div><div class='ctx'> 		int ret_btf_id;</div><div class='ctx'> </div><div class='ctx'> 		mark_reg_known_zero(env, regs, BPF_REG_0);</div><div class='del'>-		regs[BPF_REG_0].type = (ret_type &amp; PTR_MAYBE_NULL) ?</div><div class='del'>-						     PTR_TO_BTF_ID_OR_NULL :</div><div class='del'>-						     PTR_TO_BTF_ID;</div><div class='add'>+		regs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;</div><div class='ctx'> 		ret_btf_id = *fn-&gt;ret_btf_id;</div><div class='ctx'> 		if (ret_btf_id == 0) {</div><div class='ctx'> 			verbose(env, "invalid return type %u of func %s#%d\n",</div><div class='hunk'>@@ -6423,7 +6381,7 @@ static int check_helper_call(struct bpf_verifier_env *env, struct bpf_insn *insn</div><div class='ctx'> 		return -EINVAL;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	if (reg_type_may_be_null(regs[BPF_REG_0].type))</div><div class='add'>+	if (type_may_be_null(regs[BPF_REG_0].type))</div><div class='ctx'> 		regs[BPF_REG_0].id = ++env-&gt;id_gen;</div><div class='ctx'> </div><div class='ctx'> 	if (is_ptr_cast_function(func_id)) {</div><div class='hunk'>@@ -6622,25 +6580,25 @@ static bool check_reg_sane_offset(struct bpf_verifier_env *env,</div><div class='ctx'> </div><div class='ctx'> 	if (known &amp;&amp; (val &gt;= BPF_MAX_VAR_OFF || val &lt;= -BPF_MAX_VAR_OFF)) {</div><div class='ctx'> 		verbose(env, "math between %s pointer and %lld is not allowed\n",</div><div class='del'>-			reg_type_str[type], val);</div><div class='add'>+			reg_type_str(env, type), val);</div><div class='ctx'> 		return false;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> 	if (reg-&gt;off &gt;= BPF_MAX_VAR_OFF || reg-&gt;off &lt;= -BPF_MAX_VAR_OFF) {</div><div class='ctx'> 		verbose(env, "%s pointer offset %d is not allowed\n",</div><div class='del'>-			reg_type_str[type], reg-&gt;off);</div><div class='add'>+			reg_type_str(env, type), reg-&gt;off);</div><div class='ctx'> 		return false;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> 	if (smin == S64_MIN) {</div><div class='ctx'> 		verbose(env, "math between %s pointer and register with unbounded min value is not allowed\n",</div><div class='del'>-			reg_type_str[type]);</div><div class='add'>+			reg_type_str(env, type));</div><div class='ctx'> 		return false;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='ctx'> 	if (smin &gt;= BPF_MAX_VAR_OFF || smin &lt;= -BPF_MAX_VAR_OFF) {</div><div class='ctx'> 		verbose(env, "value %lld makes %s pointer be out of bounds\n",</div><div class='del'>-			smin, reg_type_str[type]);</div><div class='add'>+			smin, reg_type_str(env, type));</div><div class='ctx'> 		return false;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='hunk'>@@ -7017,11 +6975,13 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,</div><div class='ctx'> 		return -EACCES;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='del'>-	switch (ptr_reg-&gt;type) {</div><div class='del'>-	case PTR_TO_MAP_VALUE_OR_NULL:</div><div class='add'>+	if (ptr_reg-&gt;type &amp; PTR_MAYBE_NULL) {</div><div class='ctx'> 		verbose(env, "R%d pointer arithmetic on %s prohibited, null-check it first\n",</div><div class='del'>-			dst, reg_type_str[ptr_reg-&gt;type]);</div><div class='add'>+			dst, reg_type_str(env, ptr_reg-&gt;type));</div><div class='ctx'> 		return -EACCES;</div><div class='add'>+	}</div><div class='add'>+</div><div class='add'>+	switch (base_type(ptr_reg-&gt;type)) {</div><div class='ctx'> 	case CONST_PTR_TO_MAP:</div><div class='ctx'> 		/* smin_val represents the known value */</div><div class='ctx'> 		if (known &amp;&amp; smin_val == 0 &amp;&amp; opcode == BPF_ADD)</div><div class='hunk'>@@ -7034,10 +6994,10 @@ static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env,</div><div class='ctx'> 	case PTR_TO_XDP_SOCK:</div><div class='ctx'> reject:</div><div class='ctx'> 		verbose(env, "R%d pointer arithmetic on %s prohibited\n",</div><div class='del'>-			dst, reg_type_str[ptr_reg-&gt;type]);</div><div class='add'>+			dst, reg_type_str(env, ptr_reg-&gt;type));</div><div class='ctx'> 		return -EACCES;</div><div class='ctx'> 	default:</div><div class='del'>-		if (reg_type_may_be_null(ptr_reg-&gt;type))</div><div class='add'>+		if (type_may_be_null(ptr_reg-&gt;type))</div><div class='ctx'> 			goto reject;</div><div class='ctx'> 		break;</div><div class='ctx'> 	}</div><div class='hunk'>@@ -8759,7 +8719,7 @@ static void mark_ptr_or_null_reg(struct bpf_func_state *state,</div><div class='ctx'> 				 struct bpf_reg_state *reg, u32 id,</div><div class='ctx'> 				 bool is_null)</div><div class='ctx'> {</div><div class='del'>-	if (reg_type_may_be_null(reg-&gt;type) &amp;&amp; reg-&gt;id == id &amp;&amp;</div><div class='add'>+	if (type_may_be_null(reg-&gt;type) &amp;&amp; reg-&gt;id == id &amp;&amp;</div><div class='ctx'> 	    !WARN_ON_ONCE(!reg-&gt;id)) {</div><div class='ctx'> 		if (WARN_ON_ONCE(reg-&gt;smin_value || reg-&gt;smax_value ||</div><div class='ctx'> 				 !tnum_equals_const(reg-&gt;var_off, 0) ||</div><div class='hunk'>@@ -9137,7 +9097,7 @@ static int check_cond_jmp_op(struct bpf_verifier_env *env,</div><div class='ctx'> 	 */</div><div class='ctx'> 	if (!is_jmp32 &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K &amp;&amp;</div><div class='ctx'> 	    insn-&gt;imm == 0 &amp;&amp; (opcode == BPF_JEQ || opcode == BPF_JNE) &amp;&amp;</div><div class='del'>-	    reg_type_may_be_null(dst_reg-&gt;type)) {</div><div class='add'>+	    type_may_be_null(dst_reg-&gt;type)) {</div><div class='ctx'> 		/* Mark all identical registers in each branch as either</div><div class='ctx'> 		 * safe or unknown depending R == 0 or R != 0 conditional.</div><div class='ctx'> 		 */</div><div class='hunk'>@@ -9393,7 +9353,7 @@ static int check_return_code(struct bpf_verifier_env *env)</div><div class='ctx'> 		/* enforce return zero from async callbacks like timer */</div><div class='ctx'> 		if (reg-&gt;type != SCALAR_VALUE) {</div><div class='ctx'> 			verbose(env, "In async callback the register R0 is not a known value (%s)\n",</div><div class='del'>-				reg_type_str[reg-&gt;type]);</div><div class='add'>+				reg_type_str(env, reg-&gt;type));</div><div class='ctx'> 			return -EINVAL;</div><div class='ctx'> 		}</div><div class='ctx'> </div><div class='hunk'>@@ -9407,7 +9367,7 @@ static int check_return_code(struct bpf_verifier_env *env)</div><div class='ctx'> 	if (is_subprog) {</div><div class='ctx'> 		if (reg-&gt;type != SCALAR_VALUE) {</div><div class='ctx'> 			verbose(env, "At subprogram exit the register R0 is not a scalar value (%s)\n",</div><div class='del'>-				reg_type_str[reg-&gt;type]);</div><div class='add'>+				reg_type_str(env, reg-&gt;type));</div><div class='ctx'> 			return -EINVAL;</div><div class='ctx'> 		}</div><div class='ctx'> 		return 0;</div><div class='hunk'>@@ -9471,7 +9431,7 @@ static int check_return_code(struct bpf_verifier_env *env)</div><div class='ctx'> </div><div class='ctx'> 	if (reg-&gt;type != SCALAR_VALUE) {</div><div class='ctx'> 		verbose(env, "At program exit the register R0 is not a known value (%s)\n",</div><div class='del'>-			reg_type_str[reg-&gt;type]);</div><div class='add'>+			reg_type_str(env, reg-&gt;type));</div><div class='ctx'> 		return -EINVAL;</div><div class='ctx'> 	}</div><div class='ctx'> </div><div class='hunk'>@@ -10252,7 +10212,7 @@ static bool regsafe(struct bpf_verifier_env *env, struct bpf_reg_state *rold,</div><div class='ctx'> 		return true;</div><div class='ctx'> 	if (rcur-&gt;type == NOT_INIT)</div><div class='ctx'> 		return false;</div><div class='del'>-	switch (rold-&gt;type) {</div><div class='add'>+	switch (base_type(rold-&gt;type)) {</div><div class='ctx'> 	case SCALAR_VALUE:</div><div class='ctx'> 		if (env-&gt;explore_alu_limits)</div><div class='ctx'> 			return false;</div><div class='hunk'>@@ -10274,6 +10234,22 @@ static bool regsafe(struct bpf_verifier_env *env, struct bpf_reg_state *rold,</div><div class='ctx'> 		}</div><div class='ctx'> 	case PTR_TO_MAP_KEY:</div><div class='ctx'> 	case PTR_TO_MAP_VALUE:</div><div class='add'>+		/* a PTR_TO_MAP_VALUE could be safe to use as a</div><div class='add'>+		 * PTR_TO_MAP_VALUE_OR_NULL into the same map.</div><div class='add'>+		 * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-</div><div class='add'>+		 * checked, doing so could have affected others with the same</div><div class='add'>+		 * id, and we can't check for that because we lost the id when</div><div class='add'>+		 * we converted to a PTR_TO_MAP_VALUE.</div><div class='add'>+		 */</div><div class='add'>+		if (type_may_be_null(rold-&gt;type)) {</div><div class='add'>+			if (!type_may_be_null(rcur-&gt;type))</div><div class='add'>+				return false;</div><div class='add'>+			if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))</div><div class='add'>+				return false;</div><div class='add'>+			/* Check our ids match any regs they're supposed to */</div><div class='add'>+			return check_ids(rold-&gt;id, rcur-&gt;id, idmap);</div><div class='add'>+		}</div><div class='add'>+</div><div class='ctx'> 		/* If the new min/max/var_off satisfy the old ones and</div><div class='ctx'> 		 * everything else matches, we are OK.</div><div class='ctx'> 		 * 'id' is not compared, since it's only used for maps with</div><div class='hunk'>@@ -10285,20 +10261,6 @@ static bool regsafe(struct bpf_verifier_env *env, struct bpf_reg_state *rold,</div><div class='ctx'> 		return memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &amp;&amp;</div><div class='ctx'> 		       range_within(rold, rcur) &amp;&amp;</div><div class='ctx'> 		       tnum_in(rold-&gt;var_off, rcur-&gt;var_off);</div><div class='del'>-	case PTR_TO_MAP_VALUE_OR_NULL:</div><div class='del'>-		/* a PTR_TO_MAP_VALUE could be safe to use as a</div><div class='del'>-		 * PTR_TO_MAP_VALUE_OR_NULL into the same map.</div><div class='del'>-		 * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-</div><div class='del'>-		 * checked, doing so could have affected others with the same</div><div class='del'>-		 * id, and we can't check for that because we lost the id when</div><div class='del'>-		 * we converted to a PTR_TO_MAP_VALUE.</div><div class='del'>-		 */</div><div class='del'>-		if (rcur-&gt;type != PTR_TO_MAP_VALUE_OR_NULL)</div><div class='del'>-			return false;</div><div class='del'>-		if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))</div><div class='del'>-			return false;</div><div class='del'>-		/* Check our ids match any regs they're supposed to */</div><div class='del'>-		return check_ids(rold-&gt;id, rcur-&gt;id, idmap);</div><div class='ctx'> 	case PTR_TO_PACKET_META:</div><div class='ctx'> 	case PTR_TO_PACKET:</div><div class='ctx'> 		if (rcur-&gt;type != rold-&gt;type)</div><div class='hunk'>@@ -10327,11 +10289,8 @@ static bool regsafe(struct bpf_verifier_env *env, struct bpf_reg_state *rold,</div><div class='ctx'> 	case PTR_TO_PACKET_END:</div><div class='ctx'> 	case PTR_TO_FLOW_KEYS:</div><div class='ctx'> 	case PTR_TO_SOCKET:</div><div class='del'>-	case PTR_TO_SOCKET_OR_NULL:</div><div class='ctx'> 	case PTR_TO_SOCK_COMMON:</div><div class='del'>-	case PTR_TO_SOCK_COMMON_OR_NULL:</div><div class='ctx'> 	case PTR_TO_TCP_SOCK:</div><div class='del'>-	case PTR_TO_TCP_SOCK_OR_NULL:</div><div class='ctx'> 	case PTR_TO_XDP_SOCK:</div><div class='ctx'> 		/* Only valid matches are exact, which memcmp() above</div><div class='ctx'> 		 * would have accepted</div><div class='hunk'>@@ -10857,17 +10816,13 @@ next:</div><div class='ctx'> /* Return true if it's OK to have the same insn return a different type. */</div><div class='ctx'> static bool reg_type_mismatch_ok(enum bpf_reg_type type)</div><div class='ctx'> {</div><div class='del'>-	switch (type) {</div><div class='add'>+	switch (base_type(type)) {</div><div class='ctx'> 	case PTR_TO_CTX:</div><div class='ctx'> 	case PTR_TO_SOCKET:</div><div class='del'>-	case PTR_TO_SOCKET_OR_NULL:</div><div class='ctx'> 	case PTR_TO_SOCK_COMMON:</div><div class='del'>-	case PTR_TO_SOCK_COMMON_OR_NULL:</div><div class='ctx'> 	case PTR_TO_TCP_SOCK:</div><div class='del'>-	case PTR_TO_TCP_SOCK_OR_NULL:</div><div class='ctx'> 	case PTR_TO_XDP_SOCK:</div><div class='ctx'> 	case PTR_TO_BTF_ID:</div><div class='del'>-	case PTR_TO_BTF_ID_OR_NULL:</div><div class='ctx'> 		return false;</div><div class='ctx'> 	default:</div><div class='ctx'> 		return true;</div><div class='hunk'>@@ -11091,7 +11046,7 @@ static int do_check(struct bpf_verifier_env *env)</div><div class='ctx'> 			if (is_ctx_reg(env, insn-&gt;dst_reg)) {</div><div class='ctx'> 				verbose(env, "BPF_ST stores into R%d %s is not allowed\n",</div><div class='ctx'> 					insn-&gt;dst_reg,</div><div class='del'>-					reg_type_str[reg_state(env, insn-&gt;dst_reg)-&gt;type]);</div><div class='add'>+					reg_type_str(env, reg_state(env, insn-&gt;dst_reg)-&gt;type));</div><div class='ctx'> 				return -EACCES;</div><div class='ctx'> 			}</div><div class='ctx'> </div><div class='head'>diff --git a/net/core/bpf_sk_storage.c b/net/core/bpf_sk_storage.c<br/>index 68d2cbf8331ac..4cb5ef8eddbc4 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/bpf_sk_storage.c?id=3c141c82b95807473d77079936769e04a84e4ca3'>net/core/bpf_sk_storage.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/bpf_sk_storage.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>net/core/bpf_sk_storage.c</a></div><div class='hunk'>@@ -929,7 +929,7 @@ static struct bpf_iter_reg bpf_sk_storage_map_reg_info = {</div><div class='ctx'> 		{ offsetof(struct bpf_iter__bpf_sk_storage_map, sk),</div><div class='ctx'> 		  PTR_TO_BTF_ID_OR_NULL },</div><div class='ctx'> 		{ offsetof(struct bpf_iter__bpf_sk_storage_map, value),</div><div class='del'>-		  PTR_TO_RDWR_BUF_OR_NULL },</div><div class='add'>+		  PTR_TO_RDWR_BUF | PTR_MAYBE_NULL },</div><div class='ctx'> 	},</div><div class='ctx'> 	.seq_info		= &amp;iter_seq_info,</div><div class='ctx'> };</div><div class='head'>diff --git a/net/core/sock_map.c b/net/core/sock_map.c<br/>index 8288b5382f08d..5a8f3b52d08ca 100644<br/>--- a/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/sock_map.c?id=3c141c82b95807473d77079936769e04a84e4ca3'>net/core/sock_map.c</a><br/>+++ b/<a href='/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/core/sock_map.c?id=8d38cde47a7e17b646401fa92d916503caa5375e'>net/core/sock_map.c</a></div><div class='hunk'>@@ -1575,7 +1575,7 @@ static struct bpf_iter_reg sock_map_iter_reg = {</div><div class='ctx'> 	.ctx_arg_info_size	= 2,</div><div class='ctx'> 	.ctx_arg_info		= {</div><div class='ctx'> 		{ offsetof(struct bpf_iter__sockmap, key),</div><div class='del'>-		  PTR_TO_RDONLY_BUF_OR_NULL },</div><div class='add'>+		  PTR_TO_RDONLY_BUF | PTR_MAYBE_NULL },</div><div class='ctx'> 		{ offsetof(struct bpf_iter__sockmap, sk),</div><div class='ctx'> 		  PTR_TO_BTF_ID_OR_NULL },</div><div class='ctx'> 	},</div></td></tr></table></div> <!-- class=content -->
<div class='footer'>generated by <a href='https://git.zx2c4.com/cgit/about/'>cgit </a> (<a href='https://git-scm.com/'>git 2.34.1</a>) at 2023-02-02 23:00:50 +0000</div>
</div> <!-- id=cgit -->
</body>
</html>
